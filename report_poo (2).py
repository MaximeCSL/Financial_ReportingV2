# -*- coding: utf-8 -*-
"""Report_POO

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1AnU0THfNX_rp2pZVuD-A5ONgiu4f3a8o
"""

import matplotlib.pyplot as plt
import seaborn as sns
import tkinter as tk
from tkinter import filedialog
from matplotlib.backends.backend_pdf import PdfPages
import pandas as pd
import yfinance as yf
import numpy as np
import warnings
warnings.filterwarnings("ignore")

class Portfolio:

    def __init__(self, excel_file, transaction_sheet='Buy&Sell', portfolio_sheet='Portfolio'):
        self.transactions = self.read_excel(excel_file, transaction_sheet)
        self.initial_portfolio = self.read_initial_portfolio(excel_file, portfolio_sheet)
        self.data = None
        self.quantities = None
        self.total_pv = 0
        self.perf_ptf = None

    @staticmethod
    def read_excel(file_name, sheet_name):
        df = pd.read_excel(file_name, sheet_name=sheet_name, header=0)
        df.columns = [col.replace('\ufeff', '') for col in df.columns]
        return df.to_dict('records')

    @staticmethod
    def read_initial_portfolio(file_name, sheet_name="Portfolio"):
        df = pd.read_excel(file_name, sheet_name=sheet_name, header=0)
        df.columns = [col.replace('\ufeff', '') for col in df.columns]
        return df.set_index("Asset_ID")["Quantity"].to_dict()

    @staticmethod
    def download_asset_data(assets, start_date, end_date):
        data = yf.download(assets, start=start_date, end=end_date)["Close"]
        data.fillna(method='ffill', inplace=True)
        return data


    def adjust_portfolio_for_transactions1(self):

        portfolio_dict = {asset: {'Quantity': qty, 'Total_Cost': 0, 'Avg_Cost': 0} for asset, qty in self.initial_portfolio.items()}
        data = self.data
        quantities = pd.DataFrame(index=data.index, columns=data.columns).fillna(0)

        for asset, values in portfolio_dict.items():
            if asset in quantities.columns:
                quantities.at[data.index[0], asset] = values['Quantity']

        for date in data.index:

            day_transactions = [t for t in self.transactions if t['Transaction_Date'] == date]
            for transaction in day_transactions:
                asset = transaction['Asset_ID']
                price = transaction['Price_per_Unit']

                if asset not in portfolio_dict:
                    portfolio_dict[asset] = {'Quantity': 0, 'Total_Cost': 0, 'Avg_Cost': 0}

                if transaction['Transaction_Type'] == 'Buy':
                    new_qty = portfolio_dict[asset]['Quantity'] + transaction['Quantity']
                    portfolio_dict[asset]['Total_Cost'] += price * transaction['Quantity']
                    portfolio_dict[asset]['Avg_Cost'] = portfolio_dict[asset]['Total_Cost'] / new_qty
                    portfolio_dict[asset]['Quantity'] = new_qty

                elif transaction['Transaction_Type'] == 'Sell':

                    portfolio_dict[asset]['Quantity'] -= transaction['Quantity']

                    if portfolio_dict[asset]['Quantity'] <= 0:
                        portfolio_dict[asset]['Total_Cost'] = 0
                        portfolio_dict[asset]['Avg_Cost'] = 0
                    else:
                        portfolio_dict[asset]['Total_Cost'] = portfolio_dict[asset]['Avg_Cost'] * portfolio_dict[asset]['Quantity']

            for asset, values in portfolio_dict.items():
                if asset in quantities.columns:
                    quantities.at[date, asset] = values['Quantity']

        self.quantities = quantities

    def calculate_portfolio_performance(self):
        data = self.data
        quantities = self.quantities
        df_ptf_value = quantities.multiply(data).sum(axis=1).dropna()
        perf_actifs = round(data.pct_change().dropna(), 3)
        weights = quantities.multiply(data).div(df_ptf_value, axis=0).dropna()
        perf_ptf = weights.multiply(perf_actifs).dropna().sum(axis=1).dropna()
        self.perf_ptf = perf_ptf

    def analyze_portfolio(self):
        start_date = min(item["Transaction_Date"] for item in self.transactions)
        end_date = pd.to_datetime('today')
        assets = list(set([item['Asset_ID'] for item in self.transactions] + list(self.initial_portfolio.keys())))
        self.data = self.download_asset_data(assets, start_date, end_date)
        self.adjust_portfolio_for_transactions1()
        self.calculate_portfolio_performance()

    def get_cumulative_returns(self):
        return (1 + self.perf_ptf).cumprod() - 1

    def plot_cumulative_returns(self):
        self.get_cumulative_returns().plot(figsize=(12,6))
        plt.title("Rendement cumulé du portefeuille")
        plt.xlabel("Date")
        plt.ylabel("Rendement cumulé")
        plt.grid(True)
        plt.show()

    def plot_asset_diversification(self):
        last_date = self.quantities.index[-1]
        asset_values = self.quantities.loc[last_date] * self.data.loc[last_date]
        asset_values.plot.pie(autopct='%1.1f%%', figsize=(10,7))
        plt.title("Diversification du portefeuille")
        plt.show()

    def get_portfolio_stats(self):
        mean_return_daily = self.perf_ptf.mean()
        volatility_daily = self.perf_ptf.std()
        volatility_annual = volatility_daily * (252**0.5)

        # Rendement annuel moyen
        mean_return_annual = (1 + mean_return_daily)**252 - 1

        # Ratio de Sharpe
        risk_free_rate = 0.01  # taux sans risque, à adapter selon le contexte
        sharpe_ratio = (mean_return_annual - risk_free_rate) / volatility_annual

        # Ratio de Sortino
        downside_volatility = np.std(self.perf_ptf[self.perf_ptf < 0]) * (252**0.5)
        sortino_ratio = (mean_return_annual - risk_free_rate) / downside_volatility if downside_volatility != 0 else np.nan

        # Valeur à Risque (VaR) à 95%
        var_95 = np.percentile(self.perf_ptf, 5)

        # Valeur à Risque Conditionnelle (CVaR) à 95%
        cvar_95 = self.perf_ptf[self.perf_ptf <= var_95].mean()

        return {
            "Rendement moyen quotidien": mean_return_daily,
            "Volatilité quotidienne": volatility_daily,
            "Volatilité annuelle": volatility_annual,
            "Rendement annuel moyen": mean_return_annual,
            "Ratio de Sharpe": sharpe_ratio,
            "Ratio de Sortino": sortino_ratio,
            "Valeur à Risque 95%": var_95,
            "Valeur à Risque Conditionnelle 95%": cvar_95
        }

    def performance_over_periods(self):
        today = self.perf_ptf.index[-1]
        periods = {
            "1 day": today - pd.Timedelta(days=1),
            "1 week": today - pd.Timedelta(weeks=1),
            "1 month": today - pd.Timedelta(days=30),
            "3 months": today - pd.Timedelta(days=90),
            "6 months": today - pd.Timedelta(days=180),
            "1 year": today - pd.Timedelta(days=365)
        }
        performances = {}
        for period, start_date in periods.items():
            if start_date in self.perf_ptf.index:
                performances[period] = (self.perf_ptf.loc[start_date:today] + 1).prod() - 1
            else:
                # Pour les cas où la date de début n'est pas dans l'index, trouvez la date la plus proche
                nearest_date = self.perf_ptf.index[self.perf_ptf.index.get_loc(start_date, method='nearest')]
                performances[period] = (self.perf_ptf.loc[nearest_date:today] + 1).prod() - 1
        return performances


    def calculate_monte_carlo_var(self, num_simulations=1000, confidence_level=0.95):
            # Calcul des rendements quotidiens
            daily_returns = self.data.pct_change().dropna()
            # Calcul de la moyenne et de l'écart-type des rendements
            mean_return = daily_returns.mean().mean()
            std_dev = daily_returns.std().mean()
            # Simulation Monte Carlo
            simulated_returns = np.random.normal(mean_return, std_dev, num_simulations)
            # Calcul de la VaR
            var = np.percentile(simulated_returns, 100 * (1 - confidence_level))
            return var, simulated_returns
###############################################################################################################
###############################################################################################################
###############################################################################################################
###############################################################################################################
###############################################################################################################
###############################################################################################################
###############################################################################################################




# Votre code de classe Portfolio ici...

# Fonction pour ouvrir la boîte de dialogue et obtenir le chemin du fichier
def open_file_dialog():
    root = tk.Tk()
    root.withdraw()  # Cache la fenêtre Tkinter vide
    file_path = filedialog.askopenfilename(title="Sélectionnez le fichier Excel du portefeuille",
                                           filetypes=[("Fichiers Excel", "*.xlsx")])
    return file_path

# Utilisation
if __name__ == "__main__":
    excel_file_path = open_file_dialog()
    if excel_file_path:  # Vérifie si un fichier a été sélectionné
        portfolio = Portfolio(excel_file_path)
        portfolio.analyze_portfolio()
        print(portfolio.get_portfolio_stats())  # ou toute autre méthode que vous souhaitez appeler
    else:
        print("Aucun fichier sélectionné.")

# Utilisation de la classe
# portfolio = Portfolio('Portfolio.xlsx')
# portfolio.analyze_portfolio()

###############################################################################################################
###############################################################################################################
###############################################################################################################
###############################################################################################################
###############################################################################################################
###############################################################################################################
###############################################################################################################
# Style Seaborn
sns.set_style("whitegrid")
palette = sns.color_palette("husl", 10)

def stylize_table(table):
    table.auto_set_font_size(False)
    table.set_fontsize(10)
    table.scale(1.4, 1.4)
    for (i, j), cell in table.get_celld().items():
        if i == 0:
            cell.set_facecolor('#40466e')
            cell.set_text_props(color='white')
    table.auto_set_column_width(col=list(range(len(transactions_df.columns))))
    return table

with PdfPages('Financial_Reporting.pdf') as pdf:
    # Page de titre
    fig = plt.figure(figsize=(6,4))
    ax = fig.add_axes([0, 0, 1, 1])
    ax.axis('off')

    main_color = '#2c3e50'
    secondary_color = '#3c3e20'

    ax.text(0.5, 0.7, 'Financial Reporting', ha='center', va='center',
            fontsize=28, color=main_color, weight='bold')

    description = "Code disponible sur github : https://github.com/MaximeCSL "
    ax.text(0.5, 0.65, description, ha='center', va='center',
            fontsize=16, color=secondary_color)

    sous_description = "Developpé par CASALINO Maxime : https://www.linkedin.com/in/maxime-casalino-96babb178/"
    ax.text(0.5, 0.6, sous_description, ha='center', va='center',
            fontsize=14, color=secondary_color)

    ax.plot([0.25, 0.75], [0.68, 0.68], color=main_color, lw=3)
    pdf.savefig(fig, bbox_inches='tight')
    plt.close(fig)

    # Graphique de la valeur du portefeuille
    df_ptf_value = portfolio.quantities.multiply(portfolio.data).sum(axis=1).dropna()
    plt.figure(figsize=(10, 6))
    plt.plot(df_ptf_value.index, df_ptf_value.values, label='Portfolio Value', color=palette[3], linewidth=2)
    plt.xlabel('Date')
    plt.ylabel('Value')
    plt.title('Portfolio Value Over Time',weight='bold')
    plt.legend()
    plt.tight_layout()
    pdf.savefig()
    plt.close()

    # Rendement cumulé du portefeuille
    cumulative_returns = (1 + portfolio.perf_ptf).cumprod() - 1
    plt.figure(figsize=(10, 6))
    plt.plot(cumulative_returns.index, cumulative_returns.values, label='Rendement Cumulé', color=palette[3], linewidth=2)
    plt.xlabel('Date')
    plt.ylabel('Rendement Cumulé (%)')
    plt.title('Rendement cumulé du portefeuille ',weight='bold')
    plt.legend()
    plt.tight_layout()
    pdf.savefig()
    plt.close()


    performances = portfolio.performance_over_periods()
    fig, ax = plt.subplots(figsize=(10, 6))
    ax.bar(performances.keys(), [value*100 for value in performances.values()], color=palette[3])
    ax.set_ylabel('% Performance')
    ax.set_title('Performance sur différentes périodes',weight='bold')
    for i, v in enumerate(performances.values()):
        ax.text(i, v*100 + (1/10 if v*100 > 0 else -1/10), f"{v*100:.2f}%",
                ha='center', va='bottom' if v*100 > 0 else 'top', color=palette[3])

    pdf.savefig(fig, bbox_inches='tight')
    plt.close(fig)


    # 10 dernières transactions
    transactions_df = pd.DataFrame(portfolio.transactions).tail(10)
    fig, ax = plt.subplots(figsize=(10, 6))
    ax.axis('off')
    ax.table(cellText=transactions_df.values, colLabels=transactions_df.columns, cellLoc='center', loc='center')
    plt.title('10 dernières transactions',weight='bold')
    stylize_table(ax.tables[0])
    pdf.savefig(fig, bbox_inches='tight')
    plt.close(fig)

    # Répartition actuelle des actifs
    last_date = portfolio.quantities.index[-1]
    asset_values = portfolio.quantities.loc[last_date] * portfolio.data.loc[last_date]
    plt.figure(figsize=(10, 7))
    asset_values.plot.pie(autopct='%1.1f%%')
    plt.title("Répartition des actifs",weight='bold')
    plt.ylabel("")
    plt.tight_layout()
    pdf.savefig()
    plt.close()

    # Calcul et graphique de la VaR Monte Carlo
    var, simulated_returns = portfolio.calculate_monte_carlo_var()
    plt.figure(figsize=(10, 6))
    # Histogramme des rendements simulés
    sns.histplot(simulated_returns, bins=50, color=palette[3], kde=True)
    # Ligne de VaR
    plt.axvline(x=var, color='r', linestyle='--', label=f'VaR à {0.95*100}%: {var*100:.2f}%')
    plt.title('VaR Monte Carlo',weight='bold')
    plt.xlabel('Rendement')
    plt.ylabel('Fréquence')
    plt.legend()
    plt.tight_layout()
    pdf.savefig()
    plt.close()


print("Le rapport a été généré au format PDF.")

